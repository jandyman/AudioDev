# DSP External Template - Modern Max/MSP Pattern

## Why This Approach?

This attribute-based pattern is ideal because:

1. **UI Agnostic** - Parameters are exposed as attributes, not tied to inlet positions
2. **Remote Control Ready** - Attributes map directly to OSC, MIDI, network protocols
3. **Max Integration** - Inspector, automation, presets work automatically
4. **Future-Proof** - Adding WiFi/web UIs just queries/sets attributes
5. **Consistent** - Same pattern works for simple and complex DSP

## The Pattern

### File Structure
```
andy.yourmodule_tilde/
├── CMakeLists.txt           ← Universal binary config (copy from andy.gain_tilde)
├── yourmodule_tilde.cpp     ← Implementation (use template below)
├── PROJECT_OVERVIEW.md      ← Document your module
└── build/                   ← Generated by CMake
    └── externals/
        └── andy.yourmodule~.mxo
```

### Code Template

```cpp
/**
 * andy.yourmodule~ - [Brief description]
 *
 * [Detailed description]
 * Uses modern attribute-based parameter control.
 */

#include "ext.h"
#include "ext_obex.h"
#include "z_dsp.h"
#include <math.h>

// ============================================================================
// OBJECT STRUCTURE
// ============================================================================

typedef struct _yourmodule {
  t_pxobject obj;

  // User-facing parameters (exposed as attributes)
  double param1;
  double param2;
  long param3;

  // Internal state (derived from parameters)
  double internal_state1;
  double internal_state2;

  // DSP state variables
  double history1;
  double history2;

  double sample_rate;
} t_yourmodule;

static t_class *yourmodule_class = NULL;

// ============================================================================
// FUNCTION PROTOTYPES
// ============================================================================

// Lifecycle
void *yourmodule_new(t_symbol *s, long argc, t_atom *argv);
void yourmodule_free(t_yourmodule *x);

// DSP
void yourmodule_dsp64(t_yourmodule *x, t_object *dsp64, short *count,
                      double samplerate, long maxvectorsize, long flags);
void yourmodule_perform64(t_yourmodule *x, t_object *dsp64,
                          double **ins, long numins,
                          double **outs, long numouts,
                          long sampleframes, long flags,
                          void *userparam);

// Utility
void yourmodule_assist(t_yourmodule *x, void *b, long m, long a, char *s);

// Custom attribute setters
t_max_err yourmodule_param1_set(t_yourmodule *x, void *attr, long argc, t_atom *argv);
t_max_err yourmodule_param2_set(t_yourmodule *x, void *attr, long argc, t_atom *argv);
t_max_err yourmodule_param3_set(t_yourmodule *x, void *attr, long argc, t_atom *argv);

// Internal helpers
void yourmodule_calculate_internal_state(t_yourmodule *x);

// ============================================================================
// INITIALIZATION
// ============================================================================

void ext_main(void *r) {
  t_class *c;

  c = class_new("andy.yourmodule~",
                (method)yourmodule_new,
                (method)yourmodule_free,
                sizeof(t_yourmodule),
                0L,
                A_GIMME,
                0);

  class_addmethod(c, (method)yourmodule_dsp64, "dsp64", A_CANT, 0);
  class_addmethod(c, (method)yourmodule_assist, "assist", A_CANT, 0);

  // Register attributes
  CLASS_ATTR_DOUBLE(c, "param1", 0, t_yourmodule, param1);
  CLASS_ATTR_ACCESSORS(c, "param1", NULL, yourmodule_param1_set);
  CLASS_ATTR_FILTER_CLIP(c, "param1", 0.0, 1.0);
  CLASS_ATTR_LABEL(c, "param1", 0, "Parameter 1");
  CLASS_ATTR_SAVE(c, "param1", 0);
  CLASS_ATTR_DEFAULT(c, "param1", 0, "0.5");
  CLASS_ATTR_CATEGORY(c, "param1", 0, "Behavior");

  CLASS_ATTR_DOUBLE(c, "param2", 0, t_yourmodule, param2);
  CLASS_ATTR_ACCESSORS(c, "param2", NULL, yourmodule_param2_set);
  CLASS_ATTR_FILTER_CLIP(c, "param2", 20.0, 20000.0);
  CLASS_ATTR_LABEL(c, "param2", 0, "Parameter 2");
  CLASS_ATTR_SAVE(c, "param2", 0);
  CLASS_ATTR_DEFAULT(c, "param2", 0, "1000.0");
  CLASS_ATTR_CATEGORY(c, "param2", 0, "Behavior");

  CLASS_ATTR_LONG(c, "param3", 0, t_yourmodule, param3);
  CLASS_ATTR_ACCESSORS(c, "param3", NULL, yourmodule_param3_set);
  CLASS_ATTR_FILTER_CLIP(c, "param3", 0, 2);
  CLASS_ATTR_LABEL(c, "param3", 0, "Parameter 3");
  CLASS_ATTR_SAVE(c, "param3", 0);
  CLASS_ATTR_DEFAULT(c, "param3", 0, "0");
  CLASS_ATTR_ENUM(c, "param3", 0, "mode_a mode_b mode_c");
  CLASS_ATTR_CATEGORY(c, "param3", 0, "Behavior");

  class_dspinit(c);
  class_register(CLASS_BOX, c);
  yourmodule_class = c;

  post("andy.yourmodule~ - [description]");
}

// ============================================================================
// LIFECYCLE
// ============================================================================

void *yourmodule_new(t_symbol *s, long argc, t_atom *argv) {
  t_yourmodule *x = (t_yourmodule *)object_alloc(yourmodule_class);

  if (x) {
    dsp_setup((t_pxobject *)x, 1);  // Number of signal inlets
    outlet_new((t_object *)x, "signal");  // Add outlets (right to left)

    // Set default values
    x->param1 = 0.5;
    x->param2 = 1000.0;
    x->param3 = 0;

    // Initialize internal state
    x->internal_state1 = 0.0;
    x->internal_state2 = 0.0;

    // Initialize DSP state
    x->history1 = 0.0;
    x->history2 = 0.0;

    x->sample_rate = sys_getsr();
    if (x->sample_rate <= 0) {
      x->sample_rate = 44100.0;
    }

    // Process attribute arguments
    attr_args_process(x, argc, argv);

    // Calculate initial internal state
    yourmodule_calculate_internal_state(x);
  }

  return x;
}

void yourmodule_free(t_yourmodule *x) {
  dsp_free((t_pxobject *)x);
  // Free any allocated buffers here
}

// ============================================================================
// CUSTOM ATTRIBUTE SETTERS
// ============================================================================

t_max_err yourmodule_param1_set(t_yourmodule *x, void *attr, long argc, t_atom *argv) {
  if (argc && argv) {
    double value = atom_getfloat(argv);

    // Additional validation if needed
    if (value < 0.0) value = 0.0;
    if (value > 1.0) value = 1.0;

    x->param1 = value;

    // Recalculate derived state
    yourmodule_calculate_internal_state(x);
  }
  return MAX_ERR_NONE;
}

t_max_err yourmodule_param2_set(t_yourmodule *x, void *attr, long argc, t_atom *argv) {
  if (argc && argv) {
    double value = atom_getfloat(argv);

    // Nyquist limit check
    if (value > x->sample_rate * 0.48) {
      value = x->sample_rate * 0.48;
    }

    x->param2 = value;

    // Recalculate derived state
    yourmodule_calculate_internal_state(x);
  }
  return MAX_ERR_NONE;
}

t_max_err yourmodule_param3_set(t_yourmodule *x, void *attr, long argc, t_atom *argv) {
  if (argc && argv) {
    long value = atom_getlong(argv);

    if (value < 0) value = 0;
    if (value > 2) value = 2;

    x->param3 = value;

    // Recalculate derived state
    yourmodule_calculate_internal_state(x);
  }
  return MAX_ERR_NONE;
}

// ============================================================================
// INTERNAL HELPERS
// ============================================================================

void yourmodule_calculate_internal_state(t_yourmodule *x) {
  // Calculate any derived values from parameters
  // Examples:
  // - Filter coefficients from frequency/Q
  // - Phase increment from frequency
  // - Envelope segment times from ADSR values
  // - Lookup table indices
  // etc.

  // This function is called:
  // 1. After object creation
  // 2. Whenever any parameter changes
  // 3. When sample rate changes

  x->internal_state1 = x->param1 * x->param2;
  x->internal_state2 = sin(x->param2 / x->sample_rate);
}

// ============================================================================
// DSP
// ============================================================================

void yourmodule_dsp64(t_yourmodule *x, t_object *dsp64, short *count,
                      double samplerate, long maxvectorsize, long flags) {
  // Update sample rate if changed
  if (samplerate != x->sample_rate) {
    x->sample_rate = samplerate;
    yourmodule_calculate_internal_state(x);
  }

  object_method(dsp64, gensym("dsp_add64"), x, yourmodule_perform64, 0, NULL);
}

void yourmodule_perform64(t_yourmodule *x, t_object *dsp64,
                          double **ins, long numins,
                          double **outs, long numouts,
                          long sampleframes, long flags,
                          void *userparam) {
  double *in = ins[0];
  double *out = outs[0];

  // Read parameters/state once (thread-safe for simple types)
  double state1 = x->internal_state1;
  double state2 = x->internal_state2;
  long mode = x->param3;

  // Read history
  double hist1 = x->history1;
  double hist2 = x->history2;

  // Process samples
  for (long i = 0; i < sampleframes; i++) {
    double input = in[i];
    double output;

    // Your DSP algorithm here
    switch (mode) {
      case 0:  // Mode A
        output = input * state1;
        break;

      case 1:  // Mode B
        output = input * state2;
        break;

      case 2:  // Mode C
        output = input * (state1 + state2);
        break;

      default:
        output = input;
    }

    // Update history if needed
    hist2 = hist1;
    hist1 = output;

    out[i] = output;
  }

  // Store history back
  x->history1 = hist1;
  x->history2 = hist2;
}

// ============================================================================
// UTILITY
// ============================================================================

void yourmodule_assist(t_yourmodule *x, void *b, long m, long a, char *s) {
  if (m == ASSIST_INLET) {
    snprintf(s, 256, "(signal) Audio Input");
  } else {
    snprintf(s, 256, "(signal) Audio Output");
  }
}
```

## Checklist for New External

### 1. Copy Template
```bash
cd "/Users/andy/Dropbox/Developer/AudioDev/Max Experiments"
cp -r andy.gain_tilde andy.yourmodule_tilde
cd andy.yourmodule_tilde
```

### 2. Update CMakeLists.txt
```cmake
# Change project name
set(C74_EXTERNAL_NAME andy.yourmodule_tilde)

# Update source files if needed
set(EXTERNAL_SOURCES
  yourmodule_tilde.cpp
)
```

### 3. Implement Your Module
- [ ] Define object structure with parameters
- [ ] Register attributes in `ext_main()`
- [ ] Implement custom setters
- [ ] Write `calculate_internal_state()` helper
- [ ] Implement DSP algorithm in `perform64()`
- [ ] Update assist strings

### 4. Build
```bash
rm -rf build && mkdir build && cd build
cmake -G Xcode ..
xcodebuild -configuration Debug
lipo -info externals/andy.yourmodule~.mxo/Contents/MacOS/andy.yourmodule~
```

### 5. Test in Max
- [ ] Restart Max
- [ ] Create object
- [ ] Test attribute control via messages
- [ ] Test Inspector (Cmd+I)
- [ ] Test automation
- [ ] Save/load patcher to verify persistence
- [ ] Test audio processing

## UI Integration Paths

### Max Native UI
✅ **Already working:**
- Inspector panel
- Message boxes: `[param1 0.5(`
- Automation recording
- Preset saving/loading

### Future: Custom Max UI Objects
```
[live.dial @varname param1]  → Controls andy.yourmodule~ param1
[live.slider @varname param2] → Controls param2
```
Use `pattr` system to bind UI to attributes.

### Future: Remote WiFi Control (OSC)
```python
# Python OSC client
client.send_message("/max/andy.yourmodule~/1/param1", 0.75)
client.send_message("/max/andy.yourmodule~/1/param2", 2000.0)
```

Attributes map directly to OSC addresses.

### Future: Web UI
```javascript
// WebSocket or HTTP API
fetch('/api/objects/andy.yourmodule/1/attributes/param1', {
  method: 'POST',
  body: JSON.stringify({value: 0.75})
});
```

Query and set attributes over network.

### Future: MIDI Control
```
[ctlin] → [scale 0 127 0.0 1.0] → [param1 $1(
```

Or use Max's MIDI Learn to bind directly to attributes.

## Why This Pattern Works

### Separation of Concerns
```
UI Layer          → Attributes ← Remote Control
                       ↓
              Custom Setters
                       ↓
           Internal State (coefficients, etc.)
                       ↓
              DSP Processing
```

### Benefits
1. **UI Independence** - Change UI without touching DSP code
2. **Remote Ready** - Network protocols just query/set attributes
3. **Testable** - Can set attributes programmatically for unit tests
4. **Maintainable** - Clear separation between parameters and processing
5. **Consistent** - Same pattern for all modules

## Common Patterns

### Time-Based Parameters (ms to samples)
```cpp
double delay_ms;  // User parameter (milliseconds)
long delay_samples;  // Internal (samples)

t_max_err module_delay_set(t_module *x, void *attr, long argc, t_atom *argv) {
  if (argc && argv) {
    x->delay_ms = atom_getfloat(argv);
    x->delay_samples = (long)(x->delay_ms * x->sample_rate / 1000.0);
  }
  return MAX_ERR_NONE;
}
```

### Frequency-Based Parameters (Hz to radians)
```cpp
double frequency;  // User parameter (Hz)
double phase_increment;  // Internal (radians/sample)

void module_calculate_internal_state(t_module *x) {
  x->phase_increment = 2.0 * M_PI * x->frequency / x->sample_rate;
}
```

### Enum Parameters (named modes)
```cpp
CLASS_ATTR_LONG(c, "mode", 0, t_module, mode);
CLASS_ATTR_ENUM(c, "mode", 0, "bypass process freeze");
// User sees: bypass, process, freeze
// Code sees: 0, 1, 2
```

### Buffer Allocation (resize when needed)
```cpp
long buffer_size;  // User parameter
double *buffer;    // Internal buffer

t_max_err module_size_set(t_module *x, void *attr, long argc, t_atom *argv) {
  if (argc && argv) {
    long new_size = atom_getlong(argv);

    // Reallocate buffer
    if (x->buffer) {
      sysmem_freeptr(x->buffer);
    }
    x->buffer = (double *)sysmem_newptrclear(new_size * sizeof(double));
    x->buffer_size = new_size;
  }
  return MAX_ERR_NONE;
}
```

## Documentation Template

Create `PROJECT_OVERVIEW.md` for each module:

```markdown
# andy.yourmodule~ - [One-line description]

## Description
[Detailed description of what this module does]

## Parameters

### param1 (double, 0.0 to 1.0, default: 0.5)
Description of parameter 1 and its effect on the sound.

### param2 (double, 20.0 to 20000.0, default: 1000.0)
Description of parameter 2 and its effect on the sound.

### param3 (long, 0 to 2, default: 0)
- 0: Mode A - [description]
- 1: Mode B - [description]
- 2: Mode C - [description]

## Usage Examples

### Basic
```
[noise~] → [andy.yourmodule~ @param1 0.75] → [dac~]
```

### With Control
```
[noise~] → [andy.yourmodule~] → [dac~]
           ↑
[param1 $1( ← [live.dial]
```

## Algorithm Details
[Technical description of the DSP algorithm]

## Performance Notes
- CPU usage: [estimate]
- Latency: [if applicable]
- Limitations: [any known limitations]
```

## Summary

This attribute-based template is the recommended pattern because:
- ✅ Clean separation of parameters and DSP
- ✅ UI agnostic - works with any control interface
- ✅ Remote control ready
- ✅ Follows Max conventions
- ✅ Future-proof for web/mobile UIs
- ✅ Boilerplate handled by AI tools

Use this as the starting point for all new DSP externals.
